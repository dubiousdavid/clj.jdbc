<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clj.jdbc 0.1.0-beta4 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="jdbc.html"><span>jdbc</span></a></li><li><a href="jdbc.pool.html"><span>jdbc.pool</span></a></li><li><a href="jdbc.pool.c3p0.html"><span>jdbc.pool.c3p0</span></a></li><li><a href="jdbc.sql.html"><span>jdbc.sql</span></a></li><li><a href="jdbc.types.connection.html"><span>jdbc.types.connection</span></a></li><li><a href="jdbc.types.resultset.html"><span>jdbc.types.resultset</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="jdbc.html#var--%3EDefaultTransactionStrategy"><span>-&gt;DefaultTransactionStrategy</span></a></li><li><a href="jdbc.html#var-ISQLResultSetReadColumn"><span>ISQLResultSetReadColumn</span></a></li><li><a href="jdbc.html#var-ISQLType"><span>ISQLType</span></a></li><li><a href="jdbc.html#var-ITransactionStrategy"><span>ITransactionStrategy</span></a></li><li><a href="jdbc.html#var-as-sql-type"><span>as-sql-type</span></a></li><li><a href="jdbc.html#var-begin"><span>begin</span></a></li><li><a href="jdbc.html#var-call-in-transaction"><span>call-in-transaction</span></a></li><li><a href="jdbc.html#var-commit"><span>commit</span></a></li><li><a href="jdbc.html#var-execute%21"><span>execute!</span></a></li><li><a href="jdbc.html#var-execute-prepared%21"><span>execute-prepared!</span></a></li><li><a href="jdbc.html#var-execute-statement"><span>execute-statement</span></a></li><li><a href="jdbc.html#var-execute-statement-%3Equery-result"><span>execute-statement-&gt;query-result</span></a></li><li><a href="jdbc.html#var-from-sql-type"><span>from-sql-type</span></a></li><li><a href="jdbc.html#var-is-rollback-set%3F"><span>is-rollback-set?</span></a></li><li><a href="jdbc.html#var-make-connection"><span>make-connection</span></a></li><li><a href="jdbc.html#var-make-prepared-statement"><span>make-prepared-statement</span></a></li><li><a href="jdbc.html#var-make-query"><span>make-query</span></a></li><li><a href="jdbc.html#var-map-%3EDefaultTransactionStrategy"><span>map-&gt;DefaultTransactionStrategy</span></a></li><li><a href="jdbc.html#var-map-%3Eproperties"><span>map-&gt;properties</span></a></li><li><a href="jdbc.html#var-query"><span>query</span></a></li><li><a href="jdbc.html#var-result-set-%3Elazyseq"><span>result-set-&gt;lazyseq</span></a></li><li><a href="jdbc.html#var-result-set-%3Evector"><span>result-set-&gt;vector</span></a></li><li><a href="jdbc.html#var-rollback"><span>rollback</span></a></li><li><a href="jdbc.html#var-set-rollback%21"><span>set-rollback!</span></a></li><li><a href="jdbc.html#var-set-stmt-parameter%21"><span>set-stmt-parameter!</span></a></li><li><a href="jdbc.html#var-unset-rollback%21"><span>unset-rollback!</span></a></li><li><a href="jdbc.html#var-uri-%3Edbspec"><span>uri-&gt;dbspec</span></a></li><li><a href="jdbc.html#var-with-connection"><span>with-connection</span></a></li><li><a href="jdbc.html#var-with-query"><span>with-query</span></a></li><li><a href="jdbc.html#var-with-transaction"><span>with-transaction</span></a></li><li><a href="jdbc.html#var-with-transaction-strategy"><span>with-transaction-strategy</span></a></li><li><a href="jdbc.html#var-wrap-transaction-strategy"><span>wrap-transaction-strategy</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>jdbc documentation</h2><pre class="doc">Alternative implementation of jdbc wrapper for clojure.
</pre><div class="public" id="var--%3EDefaultTransactionStrategy"><h3>-&gt;DefaultTransactionStrategy</h3><div class="usage"><code>(-&gt;DefaultTransactionStrategy)</code></div><pre class="doc">Positional factory function for class jdbc.DefaultTransactionStrategy.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L111">Source</a></div></div><div class="public" id="var-ISQLResultSetReadColumn"><h3>ISQLResultSetReadColumn</h3><div class="usage"></div><pre class="doc">Protocol that exposes uniform way to convert values
obtained from result set to user types. Default implementation
available for Object, Boolean, and nil.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L78">Source</a></div></div><div class="public" id="var-ISQLType"><h3>ISQLType</h3><div class="usage"></div><pre class="doc">Protocol that exposes uniform way for convert user
types to sql/jdbc compatible types and uniform set parameters
to prepared statement instance. Default implementation available
for Object and nil values.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L69">Source</a></div></div><div class="public" id="var-ITransactionStrategy"><h3>ITransactionStrategy</h3><div class="usage"></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L106">Source</a></div></div><div class="public" id="var-as-sql-type"><h3>as-sql-type</h3><div class="usage"><code>(as-sql-type _ conn)</code></div><pre class="doc">Convert user type to sql type.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-begin"><h3>begin</h3><div class="usage"><code>(begin _ conn opts)</code></div><pre class="doc">Starts a transaction
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-call-in-transaction"><h3>call-in-transaction</h3><div class="usage"><code>(call-in-transaction conn func &amp; {:keys [savepoints strategy], :or {savepoints true}, :as opts})</code></div><pre class="doc">Wrap function in one transaction.

This function accepts as a parameter a transaction strategy. If no one
is specified, ``DefaultTransactionStrategy`` is used.

With ``DefaultTransactionStrategy``, if current connection is already in
transaction, it uses truly nested transactions for properly handle it.
The availability of this feature depends on database support for it.

Example:

  (with-connection dbspec conn
    (call-in-transaction conn (fn [conn] (execute! conn 'DROP TABLE foo;'))))

For more idiomatic code, you should use `with-transaction` macro.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L349">Source</a></div></div><div class="public" id="var-commit"><h3>commit</h3><div class="usage"><code>(commit _ conn opts)</code></div><pre class="doc">Commits a transaction
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-execute%21"><h3>execute!</h3><div class="usage"><code>(execute! conn &amp; commands)</code></div><pre class="doc">Run arbitrary number of raw sql commands such as: CREATE TABLE,
DROP TABLE, etc... If your want transactions, you can wrap this
call in transaction using `with-transaction` context block macro.

Warning: not all database servers support ddl in transactions.

Examples:

  ;; Without transactions
  (with-connection dbspec conn
    (execute! conn 'CREATE TABLE foo (id serial, name text);'))

  ;; In one transaction
  (with-connection dbspec conn
    (with-transaction conn
      (execute! conn 'CREATE TABLE foo (id serial, name text);')))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L386">Source</a></div></div><div class="public" id="var-execute-prepared%21"><h3>execute-prepared!</h3><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><pre class="doc">Same as `execute!` function, but works with PreparedStatement
instead with plain Statement.

With this you can execute multiple operations throught
one call, such as bulk update.

Example:

  (with-connection dbspec conn
    (let [sql 'UPDATE TABLE foo SET x = ? WHERE y = ?;']
      (execute-prepared! conn sql [1 2] [2 3] [3 4])))

  This code should send this sql sentences:

    UPDATE TABLE foo SET x = 1 WHERE y = 2;
    UPDATE TABLE foo SET x = 2 WHERE y = 3;
    UPDATE TABLE foo SET x = 3 WHERE y = 4;
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L412">Source</a></div></div><div class="public" id="var-execute-statement"><h3>execute-statement</h3><div class="usage"><code>(execute-statement stmt)</code></div><pre class="doc">Given a plain statement instance, execute it throught its asociated
connection and return a raw seq of results.

This is a low level interface and should be used with precaution. This
function is used internally for execue raw sql such as CREATE/DROP
table.

Status: Alpha - Implementation and name of this method can change on
following versions.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L212">Source</a></div></div><div class="public" id="var-execute-statement-%3Equery-result"><h3>execute-statement-&gt;query-result</h3><div class="usage"><code>(execute-statement-&gt;query-result conn statement)</code><code>(execute-statement-&gt;query-result conn statement options)</code></div><pre class="doc">Given a plain or prepared statement instance, return
a ResultSet instance.

This is a low level interface and should be used with precaution.

WARNING: untested

Status: Alpha - Implementation and name of this method can change on
following versions.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L227">Source</a></div></div><div class="public" id="var-from-sql-type"><h3>from-sql-type</h3><div class="usage"><code>(from-sql-type _ conn metadata index)</code></div><pre class="doc">Convert sql type to user type.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-is-rollback-set%3F"><h3>is-rollback-set?</h3><div class="usage"><code>(is-rollback-set? conn)</code></div><pre class="doc">Check if a current connection in one transaction
is marked for rollback.

This should be used in one transaction, in other case this
function always return false.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L336">Source</a></div></div><div class="public" id="var-make-connection"><h3>make-connection</h3><div class="usage"><code>(make-connection {:keys [connection-uri subprotocol subname datasource user password read-only schema], :or {read-only false, schema nil}, :as dbspec})</code></div><pre class="doc">Creates a connection to a database.

Here some simple examples, but if you want more detailed information,
please read a documentation:

  ;; Using a plain dbspec
  (with-open [c (make-connection {:subprotocol &quot;h2&quot; :subname &quot;mem:&quot;})]
    (do-somethin-with-connection c))

  ;; Using raw jdbc connection url
  (with-open [c (make-connection &quot;postgresql://user:pass@localhost/test&quot;)]
    (do-somethin-with-connection c))</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L273">Source</a></div></div><div class="public" id="var-make-prepared-statement"><h3>make-prepared-statement</h3><div class="usage"><code>(make-prepared-statement conn sqlvec)</code><code>(make-prepared-statement conn sqlvec {:keys [result-type result-concurency fetch-size max-rows holdability lazy], :or {result-type :forward-only, result-concurency :read-only, fetch-size 100}, :as options})</code></div><pre class="doc">Given connection and parametrized query as vector with first
argument as string and other arguments as params, return a
prepared statement.

Example:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println (instance? java.sql.PreparedStatement stmt)))
  ;; -&gt; true
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L440">Source</a></div></div><div class="public" id="var-make-query"><h3>make-query</h3><div class="usage"><code>(make-query conn sql-with-params)</code><code>(make-query conn sql-with-params {:keys [fetch-size lazy], :or {lazy false}, :as options})</code></div><pre class="doc">Given a connection and paramatrized sql, execute a query and
return a instance of ResultSet that works as stantard clojure
map but implements a closable interface.

This functions indents be a low level access for making queries
and it delegate to a user the resource management. You should
use ``with-open`` macro for store a result as example:

  (with-open [result (make-query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (:data result)]
      (println row)))

A ResultSet contains a these keys:

- ``:stmt`` as PreparedStatement instance
- ``:rs`` as ResultSet instance
- ``:data`` as seq of results (can be lazy or not depending on additional parameters)

NOTE: It strongly recommended not use this function directly and use a ``with-query``
macro for make query thar returns large amount of data or simple ``query`` function
that returns directly a evaluated result.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L480">Source</a></div></div><div class="public" id="var-map-%3EDefaultTransactionStrategy"><h3>map-&gt;DefaultTransactionStrategy</h3><div class="usage"><code>(map-&gt;DefaultTransactionStrategy m__5818__auto__)</code></div><pre class="doc">Factory function for class jdbc.DefaultTransactionStrategy, taking a map of keywords to field values.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L111">Source</a></div></div><div class="public" id="var-map-%3Eproperties"><h3>map-&gt;properties</h3><div class="usage"><code>(map-&gt;properties data)</code></div><pre class="doc">Convert hash-map to java.utils.Properties instance. This method is used
internally for convert dbspec map to properties instance, but it can
be usefull for other purposes.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L34">Source</a></div></div><div class="public" id="var-query"><h3>query</h3><div class="usage"><code>(query conn sqlvec)</code><code>(query conn sqlvec options)</code></div><pre class="doc">Perform a simple sql query and return a evaluated result as vector.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L522">Source</a></div></div><div class="public" id="var-result-set-%3Elazyseq"><h3>result-set-&gt;lazyseq</h3><div class="usage"><code>(result-set-&gt;lazyseq conn rs &amp; [{:keys [identifiers as-rows?], :or {identifiers str/lower-case, as-rows? false}, :as options}])</code></div><pre class="doc">Function that wraps result in a lazy seq. This function
is part of public api but can not be used directly (you should pass
this function as parameter to `query` function).

Required parameters:
  rs: ResultSet instance.

Optional named parameters:
  :identifiers -&gt; function that is applied for column name
                  when as-arrays? is false
  :as-rows?    -&gt; by default this function return a lazy seq of
                  records (map), but in certain circumstances you
                  need results as a lazy-seq of vectors. With this keywork
                  parameter you can enable this behavior and return a lazy-seq
                  of vectors instead of records (maps).
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L172">Source</a></div></div><div class="public" id="var-result-set-%3Evector"><h3>result-set-&gt;vector</h3><div class="usage"><code>(result-set-&gt;vector &amp; args)</code></div><pre class="doc">Function that evaluates a result into one clojure persistent
vector. Accept same parameters as `result-set-&gt;lazyseq`.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L206">Source</a></div></div><div class="public" id="var-rollback"><h3>rollback</h3><div class="usage"><code>(rollback _ conn opts)</code></div><pre class="doc">Rollbacks a transaction
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-set-rollback%21"><h3>set-rollback!</h3><div class="usage"><code>(set-rollback! conn)</code></div><pre class="doc">Mark a current connection for rollback.

It ensures that on the end of the current transaction
instead of commit changes, rollback them.

This function should be used inside of a transaction
block, otherwise this function does nothing.

Example:

  (with-transaction conn
    (make-some-queries-without-changes conn)
    (set-rollback! conn))</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L307">Source</a></div></div><div class="public" id="var-set-stmt-parameter%21"><h3>set-stmt-parameter!</h3><div class="usage"><code>(set-stmt-parameter! this conn stmt index)</code></div><pre class="doc">Set value to statement.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/#L">Source</a></div></div><div class="public" id="var-unset-rollback%21"><h3>unset-rollback!</h3><div class="usage"><code>(unset-rollback! conn)</code></div><pre class="doc">Revert flag setted by `set-rollback!` function.

This function should be used inside of a transaction
block, otherwise this function does nothing.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L326">Source</a></div></div><div class="public" id="var-uri-%3Edbspec"><h3>uri-&gt;dbspec</h3><div class="usage"><code>(uri-&gt;dbspec url)</code></div><pre class="doc">Parses a dbspec as uri into a plain dbspec. This function
accepts ``java.net.URI`` or ``String`` as parameter.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L50">Source</a></div></div><div class="public" id="var-with-connection"><h3>with-connection</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-connection dbspec bindname &amp; body)</code></div><pre class="doc">Given database connection paramers (dbspec), creates
a context with new connection to database that are closed
at end of code block.

If dbspec has datasource (connection pool), instead of create
a new connection, get it from connection pool and release it
at the end.

Example:

  (with-connection dbspec conn
    (do-something-with conn))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L577">Source</a></div></div><div class="public" id="var-with-query"><h3>with-query</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-query conn bindname sql-with-params &amp; body)</code></div><pre class="doc">Idiomatic dsl macro for ``query`` function that handles well queries
what returns a huge amount of results.

This method ensueres a query in one implicit transaction or
subtransaction.

Example:

  (with-query conn results
    [&quot;SELECT name FROM people WHERE id = ?&quot; 1]
    (doseq [row results]
      (println row)))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L531">Source</a></div></div><div class="public" id="var-with-transaction"><h3>with-transaction</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-transaction conn &amp; body)</code></div><pre class="doc">Creates a context that evaluates in transaction (or nested transaction).

This is a more idiomatic way to execute some database operations in
atomic way.

Example:

  (with-transaction conn
    (execute! conn 'DROP TABLE foo;')
    (execute! conn 'DROP TABLE bar;'))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L561">Source</a></div></div><div class="public" id="var-with-transaction-strategy"><h3>with-transaction-strategy</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-transaction-strategy conn strategy &amp; body)</code></div><pre class="doc">Set some transaction strategy connection in the current context
scope.

This method not uses thread-local dynamic variables and
connection preserves a transaction strategy throught threads.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L551">Source</a></div></div><div class="public" id="var-wrap-transaction-strategy"><h3>wrap-transaction-strategy</h3><div class="usage"><code>(wrap-transaction-strategy conn strategy)</code></div><pre class="doc">Simple helper function that associate a strategy
to a connection and return a new connection object
with wrapped stragy.

Example:

  (let [conn (wrap-transaction-strategy simplecon (MyStrategy.))]
    (use-your-new-conn conn))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L148">Source</a></div></div></div></body></html>